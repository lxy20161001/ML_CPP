#include <iostream>
#include <utility>
#include <vector>
#include <windows.h>
#include "ML_Cpp/LinReg/LinearSystem.h"
#include "ML_Cpp/dataSet/dataSet.h"
#include "ML_Cpp/data_split/data_split.h"
#include "ML_Cpp/StandardSDcaler.h"
#include "ML_Cpp/SimpleLinearRegression/Simp_Linear_Reg.h"
#include "ML_Cpp/PCA/PCA_.h"
#include "ML_Cpp/poly/poly.h"


int main() {

    //C++的随机数我弄不好，数值和老师的差太远，所以直接复制PYTHON的数据过来，就基本上能得出老师的数值了；
    //PolynomialFeatures自己的实现最高只能到达19，再上去就出现无解了，暂时不知道原因，未来继续优化，如果设置10的话和老师的数值完全一致；
    //

     vector<vector<double>> x={
            {1.20262273115},
            {2.0651198571},
            {1.05908601563},
            {1.36714834349},
            {2.70874774468},
            {-2.92378081779},
            {-0.518473807281},
            {-2.7071232372},
            {-2.40042863207},
            {0.048397834602},
            {-1.79851476399},
            {1.46492501288},
            {-1.84264798176},
            {1.205068513},
            {-1.24063136478},
            {1.64687672561},
            {-2.96934696742},
            {-2.32285407821},
            {-2.33427796808},
            {-1.51399062783},
            {-2.86058220457},
            {1.36392692541},
            {-0.959790348272},
            {-1.81498106164},
            {2.45507755704},
            {2.87008191009},
            {0.196815264637},
            {-1.44520890379},
            {0.502875712952},
            {-1.0458560824},
            {2.33339588266},
            {0.758427160539},
            {1.91324214347},
            {0.284072522238},
            {-0.499727964398},
            {1.45828315047},
            {-0.782421714614},
            {-2.54900073632},
            {1.65115787071},
            {-1.68354453334},
            {-2.52394723888},
            {-0.079316870741},
            {-2.077956588},
            {1.97079079951},
            {-1.85178859237},
            {-1.3775462775},
            {0.366206526811},
            {2.41428233935},
            {2.11073005058},
            {-0.491508236483},
            {-0.639142388497},
            {-2.9026769201},
            {-1.20471976893},
            {-0.877330687633},
            {2.36101599241},
            {1.71681941641},
            {1.62832155394},
            {-0.479670856398},
            {1.65615082798},
            {-0.214151138601},
            {-1.90937900569},
            {2.30415362855},
            {1.31275360708},
            {1.03128780071},
            {-1.46061820417},
            {-0.415189065216},
            {-2.9012785412},
            {-1.59003703959},
            {0.0670278669991},
            {-1.24794455753},
            {0.0113610487877},
            {-0.0103612205321},
            {-2.37737085509},
            {-0.321341307485},
            {2.8151350106},
            {1.43082672943},
            {1.3173036467},
            {2.35826031901},
            {2.77604808754},
            {-1.81769863294},
            {1.28753978532},
            {-2.02845636432},
            {2.19752863035},
            {0.74292148351},
            {2.75673074116},
            {0.144852253296},
            {-2.7814027311},
            {1.36122947138},
            {-2.97654093679},
            {-2.69823599295},
            {2.95195389525},
            {-1.72645499791},
            {2.68422398925},
            {-0.29075670714},
            {2.99276803657},
            {0.885008934855},
            {1.21344425915},
            {-0.422509407359},
            {-1.99335144095},
            {-2.29120143912},
    };

    auto X=MinMatrix<double>(x);

    vector<double> y_={4.63727759744, 6.02682982344, 4.420047632, 4.97945073131, 7.42697632687, 3.29338968867,
                       1.97544450109, 3.48008053167, 1.56664118962, 1.46461971399, 1.23488920603, 4.53074603341,
                       -0.0879387947165, 3.71096129716, -0.0415658995549, 4.81671126122, 3.70558045258, 1.7658559973,
                       1.30933463398, 3.20190140875, 3.13933776065, 3.3971434639, 2.63416451171, 3.55414414468,
                       8.07815864107, 9.57911843486, 1.58123705159, 3.46199504846, 1.75950536749, 0.716533990568,
                       6.64805744288, 4.09903398541, 5.10522138327, 4.59966152773, 3.44250093155, 4.45923716632,
                       1.77507105747, 2.78277886215, 5.37680913009, 1.64847980704, 3.544835311, -0.0682648652038,
                       2.02092833808, 5.12979610962, 0.249148456031, -0.225729709981, 2.12745768817, 7.99858364235,
                       7.74117517759, 0.700727925448, 1.83971731236, 1.77996037537, 2.67354188766, 0.604125434196,
                       7.333842618, 5.39578933058, 5.43403574036, 2.77937245252, 4.41738444374, 2.09222105932,
                       3.34554473939, 6.54686004166, 7.39169067436, 2.4481374527, 0.94768741885, 2.04458578335,
                       2.17926026612, 1.52559059805, 0.886684163807, 0.820956671615, -0.748705639344, 2.27276876983,
                       3.53639059986, 1.83778514259, 8.56935334435, 3.78785669572, 3.53006068372, 8.57317847512,
                       8.27661535676, 0.817645468638, 4.72997796653, 1.84657055687, 6.92625306192, 3.89755955178,
                       8.1294455281, 3.07572381467, 4.12481364439, 4.73812955346, 5.51421691003, 3.38268906909,
                       7.65372718838, 3.39872250701, 9.02607166191, 0.694946749496, 9.63850961516, 4.41797317203,
                       2.67725033528, 1.36003121756, 3.76082993457, 1.5459778545,};

    auto y=MinVector<double>(y_);
    
    auto new_Data=train_test_split(X, y);
    auto X_tr=get<0>(new_Data);
    auto X_test=get<1>(new_Data);
    auto y_tr=get<2>(new_Data);
    auto y_test=get<3>(new_Data);

    auto lin_reg=LinearRegression<double>().fit_normal(X_tr, y_tr);
    auto y_predict=lin_reg.predict(X_test);
    auto mse=mse_test(y_predict, y_test);
    print(mse);
    
    //以上是没有用pipeline的简单操作
    
    
    //以下是我自己对Pipeline的了解，把任何一个模块当成是插拔键，需要的时候就插进去，暂时不知道可以混合类型的vector是如何弄的~~~

    auto pip_=Pipeline<double>().fit(X, y);
    auto X_poly=pip_.addPip(PolynomialFeatures<double>(10)).fit_poly(pip_._matrix());

    auto new_Data2=train_test_split(X_poly, y);
    auto X_tr2=get<0>(new_Data2);
    auto X_test2=get<1>(new_Data2);
    auto y_tr2=get<2>(new_Data2);
    auto y_test2=get<3>(new_Data2);
    

    auto _LinLine=pip_.addPip(LinearRegression<double>()).fit_normal(X_tr2, y_tr2);
    auto y_predict2=_LinLine.predict(X_test2);
    auto mse2=mse_test(y_predict2, y_test2);
    print(mse2);


            QueryPerformanceCounter(&nEndTime);//停止计时
    time=(double) (nEndTime.QuadPart - nBeginTime.QuadPart) / (double) nFreq.QuadPart;//计算程序执行时间单位为s
    cout << "time:" << time * 1000 << "ms" << endl;


    return 0;
}

