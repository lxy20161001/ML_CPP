//
// Created by john on 2018-8-24.
//

#ifndef ML_CPP_ML_ANG_H
#define ML_CPP_ML_ANG_H

#include <iostream>
#include <vector>
#include "Numpy_Cpp.h"
#include "dataSet.h"

using namespace std;

template <typename T>
class ML_Ang{
private:
    Numpy_Cpp<T> np;
    MinVector<T> x;
    MinMatrix<T> X_train;
    MinVector<T> Y_train;
public:
    int k = 0;
    ML_Ang(){

    }
    ML_Ang(int k){
        assert(k>=1);
        this->k = k;
    }

    ~ML_Ang(){

    }

    ML_Ang fit(vector<vector<T>> x_train, vector<T> y_train){
        assert(x_train.size() == y_train.size());
        assert(this->k <= x_train.size());
        X_train=MinMatrix<T>(x_train);
        Y_train=MinVector<T>(y_train);
        return *this;
    }

    ML_Ang fit(MinMatrix<T> x_train, MinVector<T> y_train){
        assert(x_train.size() == y_train.len());
        assert(this->k <= x_train.size());
        int size = x_train.size();
        for(int i = 0; i < size ;++i){
            X_train.addMinVector(x_train[i]);
        }
        this->Y_train = MinVector<T>(y_train);
        return *this;
    }

    friend ostream &operator<<(ostream &out, ML_Ang ml_ang) {

        out << "KNN(k=";
        out << ml_ang.k;

        out << ")";
        return out;
    }


    MinVector<T> predict(vector<vector<T>> X_predict){
        assert(X_train.size()!=0 && Y_train.len()!=0);
        assert(X_predict[0].size() == this->X_train[0].len());

        vector<T> y_predict;

        for(int i = 0; i < X_predict.size();++i){
            y_predict.push_back(KNN_SINGLE(X_predict[i]));
        }
        return np.array(y_predict);
    }

    MinVector<T> predict(MinMatrix<T> X_predict){
        assert(X_train.size()!=0 && Y_train.len()!=0);
        assert(X_predict[0].len() == this->X_train[0].len());

        vector<T> y_predict;

        for(int i = 0; i < X_predict.size();++i){
            y_predict.push_back(KNN_SINGLE(X_predict[i]));
        }
        return MinVector<T>(y_predict);
    }

private:
    T KNN_SINGLE(vector<T> xt){
        assert(xt.size() == X_train[0].len());
        x = MinVector<T>(xt);
        np = Numpy_Cpp<T>(X_train,Y_train);
        vector<T> distances(static_cast<unsigned int>(X_train.size()));
        for(int i = 0 ; i<X_train.size();++i){
            distances[i] = sqrt(np.sum((X_train[i] - x) ^ 2));
        }
        auto nearest = np.MatchNum(np.argSort(MinVector<T>(distances)),Y_train);
        return Add_to_RbTree(nearest,k).sorted()[0][1];
    }

    T KNN_SINGLE(MinVector<T> x){
        assert(x.len() == X_train[0].len());
        //x = MinVector<T>(xt);
        np = Numpy_Cpp<T>(X_train,Y_train);
        vector<T> distances(static_cast<unsigned int>(X_train.size()));
        for(int i = 0 ; i<X_train.size();++i){
            distances[i] = sqrt(np.sum((X_train[i] - x) ^ 2));
        }
        auto nearest = np.MatchNum(np.argSort(MinVector<T>(distances)),Y_train);
        return  Add_to_RbTree(nearest,k).sorted()[0][1];
    }


private:

    MinMatrix<T> Add_to_RbTree(MinVector<T> nearest,int k){
        RBtree<T,T> rBtree;
        double ret = 0.0;
        for (int i = 0; i < k; ++i) {
            ret = nearest[i];
            if (rBtree.contains(ret)) {
                rBtree.set(ret, rBtree.get(ret) + 1);
            } else {
                rBtree.add(ret, 1);
            }
        }
        return MinMatrix<T>(rBtree.PreOrder());
    }


public:
    MinVector<MinMatrix<T>> train_test_split(MinMatrix<T> X,MinVector<T> y, T test_ratio = 0.2){
        assert(X.shape()[0] == y.len());

        auto shuffle_indexes = np.shuffle_indexes(X.size());
        auto test_size = int(X.size()*test_ratio);

        auto test_indexes = np.test_indexes(shuffle_indexes,0,test_size);
        auto train_indexes = np.train_indexes(shuffle_indexes,test_size,shuffle_indexes.len());

        MinMatrix<double> X_train = X.indexFancy(train_indexes,X);
        MinMatrix<double> X_test = X.indexFancy(test_indexes,X);
        MinVector<double> Y_train = y.indexFancy(train_indexes,y);
        MinVector<double> Y_test = y.indexFancy(test_indexes,y);

        vector<MinMatrix<T>> TEMP;
        MinMatrix<T> TEMP2;
        TEMP2.addMinVector(Y_train);
        TEMP2.addMinVector(Y_test);
        TEMP.push_back(X_train);
        TEMP.push_back(X_test);
        TEMP.push_back(TEMP2);


        return MinVector<MinMatrix<T>>(TEMP);
    }


    T sum(MinVector<T> A,MinVector<T> B){
        assert(A.len() == B.len());
        T ret;
        for( int i = 0; i < A.len(); ++i){
            if(A[i] == B[i]){
                ret+=1;
            }
        }
        return ret;
    }

    T Test_Res(MinVector<T> A,MinVector<T> Test){
        assert(A.len() == Test.len());
        T ret;
        for( int i = 0; i < A.len(); ++i){
            if(A[i] == Test[i]){
                ret+=1;
            }
        }
        return ret/Test.len();
    }

    T Socore(MinMatrix<T> x,MinVector<T> y){
        auto Mix = train_test_split(x,y,0.2);
        auto X_train = Mix[0];
        auto X_test = Mix[1];
        auto Y_train = Mix[2][0];
        auto Y_test = Mix[2][1];

        Numpy_Cpp<double> np;
        auto a = np.argSort(Y_test);
        auto go = fit(X_train,Y_train);
        cout<<go<<endl;
        auto predict_y = go.predict(X_test);
        auto t = go.Test_Res(predict_y,Y_test);
        return t;
    }
};

#endif //ML_CPP_ML_ANG_H
